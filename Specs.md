Okay, here is the comprehensive specification document based on our conversation, formatted as a markdown file (SPECIFICATION.md).

# Specification: Flashcard Chrome Extension (v1.0)

## 1. Overview

The project is to create a Chrome browser extension using TypeScript that allows users to quickly create flashcards from text selected on webpages. The selected text becomes the 'back' of the card, the 'front' is automatically generated by the Google Gemini LLM (but editable by the user), and the user provides a 'hint'. These flashcards are then saved to a shared Firebase Firestore database. This extension focuses *only* on adding flashcards; reviewing and difficulty updates are handled by a separate existing frontend application.

## 2. Core Functionality: Adding a Flashcard

The user flow for adding a new flashcard is as follows:

1.  **Text Selection:** The user selects text on any webpage.
2.  **Context Menu Trigger:** The user right-clicks on the selected text. A context menu option labeled "Add as Flashcard" appears.
3.  **Action Initiation:** The user clicks the "Add as Flashcard" option.
4.  **Backend Processing (Gemini Call):**
    *   The extension captures the selected text (this will be the 'back' of the flashcard).
    *   The extension's background script sends this text to the Google Gemini API (using a hardcoded API key) to request a suggested 'front' for the flashcard.
5.  **Modal Dialog Display:**
    *   Regardless of Gemini API success or failure, a modal dialog box appears overlaid on the current webpage content.
    *   **If Gemini API call succeeds:** The modal displays:
        *   An editable input field for 'Front', pre-filled with the suggestion from Gemini.
        *   A non-editable field or display area showing the 'Back' (the originally selected text).
        *   An empty, editable input field for 'Hint'.
        *   A 'Save' button.
        *   A 'Cancel' button (optional, but recommended).
    *   **If Gemini API call fails:** The modal displays:
        *   An empty, editable input field for 'Front'.
        *   A non-editable field or display area showing the 'Back'.
        *   An empty, editable input field for 'Hint'.
        *   A user-friendly error message within the modal (e.g., "Couldn't automatically generate the front. Please enter it manually.").
        *   A 'Save' button.
        *   A 'Cancel' button (optional).
6.  **User Input:**
    *   The user can edit the 'Front' text (if pre-filled or if entering manually).
    *   The user **must** enter text into the 'Hint' field.
7.  **Save Action:**
    *   The user clicks the 'Save' button.
    *   **Client-Side Validation:** The extension first validates:
        *   Is the 'Front' field empty? If yes, show an error message in the modal (e.g., "Front text cannot be empty.") and stop.
        *   Is the 'Hint' field empty? If yes, show an error message in the modal (e.g., "Hint cannot be empty.") and stop.
    *   **Data Transmission:** If validation passes, the extension sends the final `frontText`, `backText`, and `hintText` to the background script.
8.  **Backend Processing (Firebase Save):**
    *   The background script receives the validated flashcard data.
    *   It saves the data as a new document in the Firebase Firestore database (using a hardcoded API key). The document should have fields: `frontText` (string), `backText` (string), `hintText` (string), and `difficulty` (initially set to `null`).
9.  **Modal Closure:**
    *   Upon successful save (or if the user clicks 'Cancel'), the modal dialog is removed from the webpage.
    *   Error handling for Firebase save failures should be implemented (see Section 6).

## 3. Technical Architecture & Details

*   **Language:** TypeScript
*   **Platform:** Chrome Extension (Manifest V3)
*   **Core Components:**
    *   **Background Script (Service Worker):**
        *   Manages the context menu creation and listener.
        *   Handles communication with external APIs (Google Gemini, Firebase Firestore).
        *   Contains the hardcoded API keys.
        *   Orchestrates communication with the content script.
    *   **Content Script:**
        *   Injects the modal dialog UI into the active webpage's DOM when instructed by the background script.
        *   Populates the modal with data received from the background script (back text, generated front text, error messages).
        *   Handles user interaction within the modal (input, button clicks).
        *   Performs client-side validation before saving.
        *   Sends the final card data back to the background script for saving.
        *   Removes the modal from the DOM.
*   **Data Flow:**
    *   Context Menu Click -> Background Script (gets selection) -> Gemini API -> Background Script (gets response) -> Message to Content Script -> Content Script (displays modal) -> User Input -> Save Click -> Content Script (validates) -> Message to Background Script -> Background Script -> Firebase API -> Background Script (handles response) -> Message to Content Script (optional confirmation) -> Content Script (removes modal).
*   **Database:**
    *   **Service:** Firebase Firestore
    *   **Authentication:** None (Shared database via hardcoded API key). All users write to the same database.
    *   **Collection Name:** `flashcards`
    *   **Document Structure:**
        *   ID: Auto-generated by Firestore
        *   Fields:
            *   `frontText`: string
            *   `backText`: string
            *   `hintText`: string
            *   `difficulty`: null | 0 | 1 | 2 (Initially `null`. Enum values `0=Wrong`, `1=Hard`, `2=Easy` will be set by the separate frontend app during review).
*   **LLM Service:**
    *   **Service:** Google Gemini API
    *   **Authentication:** Hardcoded API Key within the background script.
    *   **Usage:** Generate suggested 'front' text based on the selected 'back' text.

## 4. User Interface (UI)

*   **Context Menu:** An option labeled "Add as Flashcard" should appear in the right-click context menu *only* when text is selected on a webpage.
*   **Modal Dialog:**
    *   Should appear clearly overlaid on the current page content.
    *   Should contain clearly labeled fields for 'Front' (input), 'Back' (display), and 'Hint' (input).
    *   Must include a 'Save' button.
    *   Should include a 'Cancel' button or a close (X) icon.
    *   Needs space to display error messages related to Gemini API failures or validation failures.
    *   Styling should be clean and unobtrusive.

## 5. API Integration Details

*   **Google Gemini API:**
    *   The background script will make HTTPS POST requests to the Gemini API endpoint.
    *   The request body will contain the selected 'back' text, formatted according to the Gemini API documentation for text generation prompts.
    *   The hardcoded API key must be included in the request headers or query parameters as required by the API.
    *   The response containing the suggested 'front' text needs to be parsed.
*   **Firebase Firestore:**
    *   The background script will interact with Firestore, likely via the Firebase REST API or potentially a minimal SDK suitable for service workers if available and appropriate.
    *   Use the hardcoded Firebase Web API key.
    *   Requests will be made to add a new document to the `flashcards` collection.
    *   The request body will contain the `frontText`, `backText`, `hintText`, and `difficulty: null`.

## 6. Error Handling

*   **Gemini API Failure:** If the call fails (network error, invalid key, API error), the modal should still appear but with an empty 'Front' field and a specific message indicating the failure and prompting manual entry (e.g., "Couldn't automatically generate the front. Please enter it manually.").
*   **Input Validation Failure:** If 'Front' or 'Hint' fields are empty when 'Save' is clicked, display a specific error message within the modal near the relevant field (e.g., "Front text cannot be empty.", "Hint cannot be empty.") and prevent the save attempt.
*   **Firebase Save Failure:** If saving to Firestore fails (network error, permissions issue, invalid data format), the background script should catch the error. Consider logging the error to the extension's console. Optionally, notify the user via the content script (e.g., display an error message like "Failed to save flashcard. Please try again.") before closing the modal, or simply close the modal and log the error silently.
*   **Network Errors:** General network errors during API calls should be caught gracefully.

## 7. Security Considerations

*   **API Keys:** Hardcoding API keys directly in the extension source code is **not secure**. Anyone can inspect the extension's code and extract the keys. For this initial version, this approach is accepted as specified, but be aware of the risks. The Gemini key could be abused, and the Firebase key allows anyone to write to the shared database.
    *   *Future Enhancement:* Implement user authentication (e.g., Firebase Auth) and use security rules to protect data. Store keys securely or use user-specific credentials.
*   **Permissions:** Request only the minimum necessary permissions in `manifest.json`.

## 8. Manifest File (`manifest.json`) Example

```json
{
  "manifest_version": 3,
  "name": "Quick Flashcard Adder",
  "version": "1.0",
  "description": "Select text on a page to quickly create flashcards.",
  "permissions": [
    "contextMenus",
    "scripting"
  ],
  "host_permissions": [
    "https://generativelanguage.googleapis.com/*",
    "https://firestore.googleapis.com/*"
     // Add other specific domains if needed by SDKs/APIs
  ],
  "background": {
    "service_worker": "background.js"
  },
  "action": {}
}


(Note: Adjust API host permissions URLs to be as specific as possible for your actual endpoints).

9. Testing Plan

Unit Tests:

Test validation logic for 'Front' and 'Hint' fields.

Test message formatting between background and content scripts.

Mock API call functions in the background script to test success/error handling logic.

Integration Tests:

Test the message passing flow: Context Menu -> Background -> Content -> Background -> Firebase.

Use mock API endpoints for Gemini and Firebase to simulate responses and failures.

Manual End-to-End Tests:

Install the extension in Chrome.

Visit various websites (simple, complex, dynamic content).

Select different types of text (short, long, with special characters).

Verify context menu option appears only on selection.

Trigger the action:

Test Gemini success case: Verify modal appears with pre-filled 'front', correct 'back'. Edit 'front', add 'hint', save. Verify modal closes.

Test Gemini failure case: Simulate API failure. Verify modal appears with empty 'front', error message, correct 'back'. Enter 'front'/'hint', save. Verify modal closes.

Test validation: Try saving with empty 'front'/'hint'. Verify error messages appear and save is prevented.

Verify data in Firebase Firestore: Check if new documents are created with the correct frontText, backText, hintText, and difficulty: null.

Test the 'Cancel' button/action.

10. Future Considerations (Post v1.0)

Implement User Authentication (e.g., Firebase Authentication) to allow users to save flashcards to their own private collections.

Add Firebase Security Rules to protect user data.

Provide an Options page for users to potentially manage settings or view stats.

Consider more robust API key management instead of hardcoding.

Add visual feedback on successful save (e.g., a temporary success message).

IGNORE_WHEN_COPYING_START
content_copy
download
Use code with caution.
IGNORE_WHEN_COPYING_END